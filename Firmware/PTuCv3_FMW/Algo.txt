1 приоритет двигатель внешнего бункера если работает он не работают подача и колосник.
2 когда работает подача не работает колосник.
3 если нет внешнего шнека приоритет подача .
4 если срабатывает датчик на пустую трубу подачи с внешнего бункера отключаются двигателя колосника,
 подачи в горелку если в этот момент работают. включается двигатель внешнего бункера и крутит
  пока  датчик загрузки не увидит топлево . когда датчик увидел топлево двигатель внешнего
   бункера крутит еще 4 сек и выключается после контролер включает поставленые задачи
   по подачи топлева в топку и после движение колостника.
если сработал датчик топлева и двигатель подачи внешнего бункера включился и датчик не видет
топлево в течении трех минут то включается ошибка вентилятор дует еще 300 сек и останавливает
 горелку.и электроника писчит встроеной писчалкой продолжительными гудками пока
 не нажмут любую кнопку.
5 если срабатывает термостат перегрева електроника начинает писчать безпрерывно пока
 не нажмут любую кнопку.при этом двигатель подачи крутит 10 сек и ждет 3 мин пока термостат
  не вернется в прежнее положение. если возвращается больше не крутит но продолжает писчать.
   если не вернулся все повторяется и так. 5 раз.



   Код:
//----------------------------------------------------------------------------

//Keyboard support module

//----------------------------------------------------------------------------

#include "Main.h"
#include "Keyboard.h"

//----------------------------- Constants: -----------------------------------

#define DBOUNCE_TIME           50 //debounce time, ms
#define AUTOREPEAT_DELAY      800 //initial autorepeat delay,   mS
#define AUTOREPEAT_SLOW_RATE  180 //slow autorepeat rate,   mS
#define AUTOREPEAT_SLOW_COUNT  16   //slow autorepeat step count
#define AUTOREPEAT_FAST_RATE   60   //fast autorepeat rate,   mS

//------------------------------ Variables: ----------------------------------

static char KeyCode;

//------------------------- Function prototypes: -----------------------------

char Scan(void);

//---------------------------- Keyboard init: --------------------------------

void Keyboard_Init(void)
{
  KeyCode = KEY_NO;
}

//---------------------------- Scan keyboard: --------------------------------

char Scan(void)
{
  char d = 0xEF;
  for(char i = 0; i < 8; i++)
  {
    Port_SCLK_0;
    if(d & 0x80) Port_DATA_1;
      else Port_DATA_0;
    d = d << 1;
    Port_SCLK_1;
    if(Pin_RETL) d = d | 1;
  }
  switch(~d & 0x0F)
  {
  case 0x01: d = KEY_MN; break; //key "MENU"
  case 0x02: d = KEY_DN; break; //key "DOWN"
  case 0x04: d = KEY_UP; break; //key "UP"
  case 0x06: d = KEY_UD; break; //key "UP" + "DOWN"
  case 0x08: d = KEY_OK; break; //key "OK"
  default : d = KEY_NO;
  }
  return(d);
}

//-------------------------- Keyboard processing: ----------------------------

void Keyboard_Exe(bool t)
{
  static char LastCode = KEY_NO;
  static char TempCode = KEY_NO;
  static char DbncTimer = 0;
  static int  RepTimer = 0;
  static char RepCnt = 0;

  if(t)
  {
    if(DbncTimer) DbncTimer--;
    if(RepTimer) RepTimer--;
    char k = Scan();
    if(k != LastCode) //new press
    {
      if(k != TempCode) //bounce
      {
        TempCode = k;
        DbncTimer = ms2sys(DBOUNCE_TIME);
      }
      else
      {
        if(!DbncTimer)
        {
          if(k != KEY_NO) //key pressed
          {
            RepTimer = ms2sys(AUTOREPEAT_DELAY);
            KeyCode = k;
          }
          LastCode = k;
          RepCnt = 0;
        }
      }
    }
    else //key holded
    {
      if(RepTimer == 1) //repeat timer is over
      {
        if(RepCnt < AUTOREPEAT_SLOW_COUNT)
        {
          KeyCode = k | REP_S; //slow autorepeat
          RepTimer = ms2sys(AUTOREPEAT_SLOW_RATE);
          RepCnt++;
        }
        else
        {
          KeyCode = k | REP_F; //fast autorepeat
          RepTimer = ms2sys(AUTOREPEAT_FAST_RATE);
        }
      }
    }
  }
}

//----------------------------- Get key code: --------------------------------

char Keyboard_GetCode(void)
{
  char code = KeyCode;
  KeyCode = KEY_NO;
  return(code);
}

//----------------------------------------------------------------------------
